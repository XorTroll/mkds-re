import idautils
import ida_nalt
import idaapi
import ida_enum
import ida_struct
import ida_funcs
import ida_typeinf
import ida_kernwin
import ida_bytes
import ida_name
import os
from datetime import datetime

# Script used from my IDA database to generate all-in-one header and symbols.x files, all ready for some fun ASM hacking

TAB = "    "

def gen_symbols_x(out_file):
    with open(out_file, "w") as f:
        for func_ea in idautils.Functions():
            func_name = ida_funcs.get_func_name(func_ea)
            func = ida_funcs.get_func(func_ea)

            f.write(f"{func_name} = 0x{func_ea:08X};\n")

        f.write("\n")

        for (ea, name) in idautils.Names():
            if name.startswith("g_"):
                f.write(f"{name} = 0x{ea:08X};\n")

    print(f"Done, exported symbols to '{out_file}'")


BASE_TYPES = [
    "int",
    "char",
    "void",
    "__int16",
    "__int32",
    "__int64",
    "u8",
    "u16",
    "u32",
    "u64",
    "BOOL",
    "_BYTE",
    "_WORD",
    "_DWORD",
    "_QWORD"
]

def export_all_to_header(out_types_header_file, out_syms_header_file):
    with open(out_types_header_file, "w") as f:
        now = datetime.now()

        f.write("/* MKDS (EU) ARM9 type definitions */\n")
        f.write(f"/* Generated by mkdsdecomp: https://github.com/XorTroll/mkdsdecomp, at {now.strftime('%B %d, %Y %I:%M:%S %p')} */\n\n")

        f.write("#ifndef MKDSDECOMP_TYPES_GEN_H\n")
        f.write("#define MKDSDECOMP_TYPES_GEN_H\n\n")

        f.write("/* Basic IDA types and definitions */\n\n")

        f.write("#define int16_t short\n")
        f.write("#define int32_t int\n")
        f.write("#define int64_t long long\n")
        f.write("#define uint8_t unsigned char\n")
        f.write("#define uint16_t unsigned short\n")
        f.write("#define uint32_t unsigned int\n")
        f.write("#define uint64_t unsigned long long\n")
        
        f.write("#define u8 uint8_t\n")
        f.write("#define u16 uint16_t\n")
        f.write("#define u32 uint32_t\n")
        f.write("#define u64 uint64_t\n")

        f.write("#define _BYTE uint8_t\n")
        f.write("#define _WORD int16_t\n")
        f.write("#define _DWORD int32_t\n")
        f.write("#define _QWORD int64_t\n")

        f.write("#define BOOL int\n")

        f.write("#define __int8 char\n")
        f.write("#define __int16 short\n")
        f.write("#define __int32 int\n")
        f.write("#define __int64 long long\n")

        f.write("#define __cdecl\n")
        f.write("#define __fastcall\n")
        f.write("#define __usercall\n\n")
        f.write("#define __noreturn __attribute__((noreturn))\n\n")

        f.write("_Static_assert(sizeof(u8) == 1, \"u8 definition\");\n")
        f.write("_Static_assert(sizeof(u16) == 2, \"u16 definition\");\n")
        f.write("_Static_assert(sizeof(u32) == 4, \"u32 definition\");\n")
        f.write("_Static_assert(sizeof(u64) == 8, \"u64 definition\");\n\n")

        f.write(f"/* Enums ({ida_enum.get_enum_qty()} total) */\n\n")

        for enum_idx in range(ida_enum.get_enum_qty()):
            enum = ida_enum.getn_enum(enum_idx)
            enum_name = ida_enum.get_enum_name(enum)
            f.write(f"enum {enum_name} {{\n")

            cur_member_value = ida_enum.get_first_enum_member(enum, 0xffffffff)
            last_member_value = ida_enum.get_last_enum_member(enum, 0xffffffff)
            while True:
                cur_member_id = ida_enum.get_enum_member(enum, cur_member_value, -1, 0xffffffff)
                
                member_name = ida_enum.get_enum_member_name(cur_member_id)
                member_value = ida_enum.get_enum_member_value(cur_member_id)
                f.write(f"{TAB}{member_name} = {member_value},\n")

                if cur_member_value == last_member_value:
                    break
                cur_member_value = ida_enum.get_next_enum_member(enum, cur_member_value, 0xffffffff)

            f.write("};\n\n")

        done_struct_ids = []
        
        struct_count = len(list(idautils.Structs()))
        f.write(f"/* Structs ({struct_count} total) */\n\n")

        for (struct_id, struct_sid, struct_name) in idautils.Structs():
            struct = ida_struct.get_struc(struct_sid)
            if struct is not None:
                type_keyword = "union" if struct.is_union() else "struct"
                f.write(f"typedef {type_keyword} {struct_name} {struct_name};\n\n")

        iter_lim = 0
        while len(done_struct_ids) < struct_count:
            iter_lim += 1
            if iter_lim > 20:
                break
            print(f"[{iter_lim}] Remaining structs: {struct_count - len(done_struct_ids)}")
            for (struct_id, struct_sid, struct_name) in idautils.Structs():
                if struct_id in done_struct_ids:
                    continue

                struct = ida_struct.get_struc(struct_sid)
                struct_size = ida_struct.get_struc_size(struct)

                can_add = True
                try:
                    for (mem_off, mem_name, mem_size) in idautils.StructMembers(struct_sid):
                        if not can_add:
                            break

                        mem = ida_struct.get_member(struct, mem_off)
                        mem_id = ida_struct.get_member_id(struct, mem_off)
                        tinfo = idaapi.tinfo_t()
                        ida_struct.get_member_tinfo(tinfo, mem)

                        # Ensure proper type order, only add structs whose field struct types have already been added (unless they are just pointers)
                        mem_type_base = idaapi.print_tinfo("", 0, 0, ida_typeinf.PRTYPE_1LINE, tinfo, "", "")
                        mem_type = mem_type_base.split(" ")[0].split("[")[0]
                        if mem_type in BASE_TYPES:
                            pass
                        elif mem_type == struct_name:
                            pass
                        elif mem_type_base.endswith(" *"):
                            pass
                        else:
                            for (inner_struct_id, inner_struct_sid, inner_struct_name) in idautils.Structs():
                                if mem_type == inner_struct_name:
                                    if inner_struct_id not in done_struct_ids:
                                        can_add = False
                                        break
                except:
                    print(f"Issue with {struct_name}...")

                if can_add:
                    if struct is not None:
                        f.write(f"/* size 0x{struct_size:X} */\n")

                        is_union = struct.is_union()
                        type_keyword = "union" if is_union else "struct"
                        f.write(f"{type_keyword} {struct_name} {{\n")
                        try:
                            for (mem_off, mem_name, mem_size) in idautils.StructMembers(struct_sid):
                                mem = ida_struct.get_member(struct, mem_off)
                                mem_id = ida_struct.get_member_id(struct, mem_off)
                                tinfo = idaapi.tinfo_t()
                                ida_struct.get_member_tinfo(tinfo, mem)
                                mem_fmt = idaapi.print_tinfo("", 0, 0, ida_typeinf.PRTYPE_1LINE, tinfo, mem_name, "")
                                f.write(f"{TAB}/* off 0x{mem_off:X} size 0x{mem_size:X} */\n")
                                f.write(f"{TAB}{mem_fmt};\n\n")
                        except:
                            print(f"Other issue with {struct_name}...")
                        f.write(f"}} __attribute__((packed));\n")
                        if not is_union:
                            f.write(f"_Static_assert(sizeof({struct_name}) == 0x{struct_size:X}, \"{struct_name} definition\");\n\n")
                    else:
                        print(f"Issue with {struct_name}...")

                    done_struct_ids.append(struct_id)
                else:
                    print(f"Cannot add {struct_name}...")

        if struct_count > len(done_struct_ids):
            f.write(f"/* (failed struct types: {struct_count - len(done_struct_ids)}) */\n\n")

        f.write("#endif // MKDSDECOMP_TYPES_GEN_H\n")
        print(f"Done, exported types header to '{out_types_header_file}'")

    if out_syms_header_file is not None:
        with open(out_syms_header_file, "w") as f:
            f.write("/* MKDS (EU) ARM9 function/symbol definitions */\n")
            f.write(f"/* Generated by mkdsdecomp: https://github.com/XorTroll/mkdsdecomp, at {now.strftime('%B %d, %Y %I:%M:%S %p')} */\n\n")

            f.write("#ifndef MKDSDECOMP_SYMS_GEN_H\n")
            f.write("#define MKDSDECOMP_SYMS_GEN_H\n\n")

            f.write(f"#include \"{os.path.basename(out_types_header_file)}\"\n\n")

            f.write(f"/* Global objects */\n\n")

            for (ea, name) in idautils.Names():
                if name.startswith("g_"):
                    type = ida_typeinf.tinfo_t()
                    ida_nalt.get_tinfo(type, ea)
                    expr = ida_typeinf.print_tinfo("", 0, 0, ida_typeinf.PRTYPE_1LINE, type, name, "")
                    if expr is not None:
                        f.write(f"/* off 0x{ea:08X} */\n")
                        f.write(f"extern {expr};\n\n")

            func_count = len(list(idautils.Functions()))
            f.write(f"/* Functions ({func_count} total) */\n\n")
            
            for func_ea in idautils.Functions():
                func = ida_funcs.get_func(func_ea)
                if func is None:
                    print(f"Function not found at address 0x{func_ea:08X}")
                    continue

                func_type = ida_typeinf.tinfo_t()
                if not ida_nalt.get_tinfo(func_type, func.start_ea):
                    print(f"Function signature not found for function at address 0x{func_ea:08X}")
                    continue
                
                function_name = ida_funcs.get_func_name(func_ea)
                func_sig = ida_typeinf.print_tinfo("", 0, 0, ida_typeinf.PRTYPE_1LINE, func_type, function_name, "")

                f.write(f"/* off 0x{func_ea:08X} */\n")
                f.write(f"{func_sig};\n\n")
            
            f.write("#endif // MKDSDECOMP_SYMS_GEN_H\n")
            print(f"Done, exported symbols header to '{out_syms_header_file}'")

symbols_x_path = ida_kernwin.ask_file(1, "*.x", "Export symbols.x file")
if symbols_x_path is not None:
    gen_symbols_x(symbols_x_path)

types_header_path = ida_kernwin.ask_file(1, "*.h", "Export C types header file")
syms_header_path = ida_kernwin.ask_file(1, "*.h", "Export C symbols header file")
if types_header_path is not None:
    export_all_to_header(types_header_path, syms_header_path)
